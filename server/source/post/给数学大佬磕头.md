---
title: ç»™æ•°å­¦å¤§ä½¬ç£•å¤´
tags: æ•°æ®ç»“æ„ äººç”Ÿåœ¨ä¸–ä¸å¦‚æ„
class: ç”Ÿæ´» çœŸçš„å—
---

sæ•°æ®ç»“æ„è®²å®è¯ï¼Œå¤ªå¦™äº†ï¼Œçœ‹åˆ°ç°åœ¨ï¼Œå˜´è§’éƒ½æ˜¯ä¸Šæ‰¬çš„ãƒ¾(â€¢Ï‰â€¢`)oï¼ŒçœŸçš„ä½©æœç ”ç©¶è¿™äº›çš„æ•°å­¦å®¶ä»¬ï¼Œç”¨äº†è¿™ä¹ˆå·§å¦™çš„æ–¹æ³•è§£å†³äº†è¿™ä¹ˆå¤æ‚çš„é—®é¢˜ï¼Œæˆ‘åªèƒ½è¯´ï¼ŒğŸ‚ï¼Œå¸Œæœ›æœ‰ä¸€å¤©æˆ‘ä¹Ÿèƒ½æˆä¸ºå‘æ˜ç›¸å…³ç®—æ³•çš„å¤§ä½¬æã€‚![Cheems.png](https://i.loli.net/2021/11/28/2AeiL7N9ysnCT6K.png)

<!-- more -->

åªèƒ½å­¦ä¹ ç†è®ºæ²¡ç»ƒä¹ åšéº»äº†![å›°æƒ‘.jpg](https://i.loli.net/2021/11/28/7nMNtjshfviYd21.jpg)

##  3.6--3.16



```c
#include <stdio.h>
#define ElemType int
#define Status int 
#define ERROR 0
#define OK 1
/*çº¿æ€§è¡¨çš„å•é“¾è¡¨å‚¨å­˜ç»“æ„*/
typedef struct Node
{
	ElemType data;
	struct Node* next;/*å®šä¹‰LinkList*/
}Node;
typedef struct Node* LinkList;
/*èŠ‚ç‚¹Nodeç”±  å­˜æ”¾ æ•°æ®å…ƒç´  çš„æ•°æ®åŸŸ  å’Œ  å­˜æ”¾ åç»§èŠ‚ç‚¹åœ°å€ çš„æŒ‡é’ˆç»„æˆ  */
/*******************
GetElemæ“ä½œæµç¨‹ï¼š
ç®—äº†ï¼Œä¸å†™äº†
*******************/
Status GetElem(LinkList L, int i, ElemType* e)
{
	int j;
	LinkList p;
	p = L->next;
	j = 1;
	while (p && j < i)
	{
		p = p->next;
		++j;
	}
	if (!p || j > i)
		return ERROR;
	*e = p->data;
	return OK;
}
/*
s->next = p->next;å°†pçš„åè®°èŠ‚ç‚¹èµ‹ç»™sçš„åç»§èŠ‚ç‚¹
p->next = s;å°†sèµ‹å€¼ç»™0çš„åç»§èŠ‚ç‚¹*/
Status ListDelete(LinkList* L, int i, ElemType* e)
{
	int j;
	LinkList p, q;
	p = *L;
	j = 1;
	while (p->next && j < i)
	{
		p = p->next;
		++j;
	}
	if (!(p->next) || j > i)
	{
		return ERROR;
	}
	q = p->next;
	p->next = q->next;
	*e = q->data;
	free(q);
	return OK;
}
void CreateListHead(LinkList* L, int n)
{
	LinkList p;
	int i;
	srand(time(0));
	*L = (LinkList)malloc(sizeof(Node));
	(*L)->next = NULL;
	for (i = 0; i < n; i++)
	{
		p = (LinkList)malloc(sizeof(Node));
		p->data = rand() % 100 + 1;
		p->next = (*L)->next;//pçš„åç»§æ”¹æˆ*LåŸæ¥çš„åç»§
		(*L)->next = p;//å°†på˜æˆ*Lç°åœ¨çš„åç»§
	}
}



void CreateListTail(LinkList* L, int n)
{
	LinkList p, r;
	int i;
	srand(time(0));
	*L = (LinkList)malloc(sizeof(Node));
	r = *L;
	for (i = 0; i < n; i++)
	{
		p = (Node*)malloc(sizeof(Node));
		p->data = rand() % 100 + 1;
		r->next = p;//å°†è¡¨å°¾ç»ˆç«¯èŠ‚ç‚¹çš„æŒ‡é’ˆæŒ‡å‘æ–°èŠ‚ç‚¹
		r = p;//å°†å½“å‰çš„æ–°èŠ‚ç‚¹å®šä¹‰ä¸ºç»ˆç«¯èŠ‚ç‚¹
	}
	r->next = NULL;
}

Status ClearList(LinkList* L)
{
	LinkList p, q;
	p = (*L)->next;
	while (p)
	{
		q = p->next;
		free(p);
		p = q;
	}
		(*L)->next = NULL;//å¤´èŠ‚ç‚¹æŒ‡é’ˆåŸŸä¸ºç©º
		return OK;
}
/*
è‹¥çº¿æ€§è¡¨éœ€è¦é¢‘ç¹æŸ¥æ‰¾ï¼Œå¾ˆå°‘è¿›è¡Œæ’å…¥å’Œåˆ é™¤æ“ä½œæ—¶ï¼Œå®œé‡‡ç”¨é¡ºåºå‚¨å­˜ç»“æ„
è‹¥çº¿æ€§è¡¨ä¸­çš„å…ƒç´ ä¸ªæ•°å˜åŒ–è¾ƒå¤§æˆ–è·Ÿæœ¬ä¸çŸ¥é“æœ‰å¤šå¤§æ—¶ï¼Œæœ€å¥½é‡‡ç”¨å•é“¾è¡¨ç»“æ„
*/
//é™æ€é“¾è¡¨
//æ•°ç»„æè¿°çš„é“¾è¡¨å«åšé™æ€é“¾è¡¨

#define MAXSIZE 1000

typedef struct
{
	ElemType data;
	int cur;//æ¸¸æ ‡(Cursor),ä¸º0æ—¶è¡¨ç¤ºæ— æŒ‡å‘
}
Component,StaticLinkList[MAXSIZE];

Status InitList(StaticLinkList space)
{
	int i;
	for (i = 0; i < MAXSIZE - 1; i++)
	{
		space[i].cur = i + 1;
	}
	space[MAXSIZE - 1].cur = 0;
	return OK;
}

Status Malloc_SSL(StaticLinkList space)
{
	int i = space[0].cur;
	/*å½“å‰æ•°ç»„ç¬¬ä¸€ä¸ªå…ƒç´ çš„curå­˜çš„å€¼å°±æ˜¯è¦è¿”å›çš„ç¬¬ä¸€ä¸ªå¤‡ç”¨ç©ºé—´çš„ä¸‹æ ‡*/

	if (space[0].cur)
	{
		space[0].cur = space[i].cur;
		/*ç”±äºè¦æ‹¿å‡ºæ¥ä¸€ä¸ªåˆ†é‡æ¥ä½¿ç”¨äº† æ‰€ä»¥æˆ‘ä»¬å°±å¾—æŠŠå®ƒçš„ä¸‹ä¸€ä¸ªåˆ†é‡ç”¨æ¥åšå¤‡ç”¨*/
	}
	return i;
}

Status ListInsert(StaticLinkList L, int i, ElemType e)
{
	int j, k, l;
	k = MAXSIZE - 1;
	if (i<1 || i>ListLength(L) + 1)
		return ERROR;
	j = Malloc_SSL(L);//è·å¾—ç©ºé—²åˆ†é‡çš„ä¸‹æ ‡
	if (j)
	{
		L->data = e;//å°†æ•°æ®èµ‹å€¼ç»™æ­¤åˆ†é‡çš„data
		for (l = 1 ;l <= i - 1; l++)//æ‰¾åˆ°ç¬¬iä¸ªå…ƒç´ ä¹‹å‰çš„ä½ç½®
		{
			k = L[k].cur;
		}
		L[j].cur = L[k].cur;	//æŠŠç¬¬iä¸ªå…ƒç´ ä¹‹å‰çš„curèµ‹å€¼ç»™æ–°å…ƒç´ çš„cur
		L[k].cur = j;			//æŠŠæ–°å…ƒç´ çš„ä¸‹æ ‡èµ‹å€¼ç»™ç¬¬iä¸ªå…ƒç´ ä¹‹å‰å…ƒç´ çš„cur
		return OK;
	}
	return ERROR;
}

Status ListDelete(StaticLinkList L, int i)
{
	int j, k;
	if (i<1 || i>ListLength(L))
		return ERROR;
	k = MAXSIZE - 1;
	for (j = 1; j <= i - 1; j++)
	{
		k = L[k].cur;
	}
	j = L[k].cur;
	L[k].cur = L[j].cur;
	Free_SSL(L, j);
	return OK;
}

void Free_SSL(StaticLinkList space, int k)
{
	space[k].cur = space[0].cur;	//æŠŠç¬¬ä¸€ä¸ªå…ƒç´ çš„curèµ‹å€¼ç»™è¦åˆ é™¤åˆ†é‡cur
	space[0].cur = k;	//æŠŠè¦åˆ é™¤çš„åˆ†é‡ä¸‹æ ‡èµ‹å€¼ç»™ç¬¬ä¸€ä¸ªå…ƒç´ çš„cur
}

int ListLength(StaticLinkList L)
{
	int j = 0;
	int i = L[MAXSIZE - 1].cur;
	while (i)
	{
		i = L[i].cur;
		j++;
	}
	return j;
}
/*å¾ªç¯åˆ—è¡¨*/
/*
p=rearA->next;//ä¿å­˜Aè¡¨çš„å¤´èŠ‚ç‚¹ï¼Œå³1
rearA->next=rearB->next->next;//å°†æœ¬æ˜¯æŒ‡å‘Bè¡¨çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆä¸æ˜¯å¤´èŠ‚ç‚¹ï¼‰èµ‹å€¼ç»™rearA->nextï¼Œå³2

q = rearB->next;
rearB->next = p;//å°†åŸAè¡¨çš„å¤´èŠ‚ç‚¹èµ‹å€¼ç»™rearB->nextï¼Œå³3
free(q);é‡Šæ”¾q
*/

/*åŒå‘åˆ—è¡¨*/

/*
typedef struct DulNode
{

ElemType data;
struct DulNode *prior//ç›´æ¥å‰é©±æŒ‡é’ˆ
struct DulNode *next;//ç›´æ¥åé©±æŒ‡é’ˆ

}DulNode,*DuLinkList;
*/

//p->next->prior = p = p->prior->next
/*
æ’å…¥
s->prior = p;
s->next = p->next;
p->next->prior =s;
p->next =s
*/

/*
åˆ é™¤
p->prior->next = p->next;
p->next->prior = p->prior
free(p)
*/

```
2.43äº†ï¼Œå…„å¼Ÿä»¬ï¼Œå›°å‘Šï¼![ç¡è§‰.jpg](https://i.loli.net/2021/11/28/E6cIWDx4LpnfRMa.jpg)
